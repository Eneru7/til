# 行格式

真正的数据在**外存**中，操作数据的过程在**内存**中。

每次操作是**一条一条**从外存中读取？显然不是，这样IO次数太多，速度太慢。

InnoDB采取的方式：将数据划分为若干个==页==，以==页==作为磁盘和内存交互的**基本单位**，一般为**16KB**。

平常我们使用MySQL操作的一条记录，实际存储情况其实不止我们表面看到的那些数据，即不只是我们表中设计的那些列。这些记录在磁盘上的存放方式称之为==行格式==或者==记录格式==。主要了解`Compact`行格式。

使用指定行格式：

```mysql
mysql> CREATE TABLE record_format_demo (
-> c1 VARCHAR(10),
-> c2 VARCHAR(10) NOT NULL,
-> c3 CHAR(10),
-> c4 VARCHAR(10)
-> ) CHARSET=ascii ROW_FORMAT=COMPACT;
Query OK, 0 rows affected (0.03 sec)
```

![image-20221017204946788](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017204946788.png)

* **记录的额外信息**

  1. 变长字段长度列表

     把拥有**变长**数据类型的列称为变长字段，变长字段中存储多少字节的数据是不固定的，，所以在存储真实数据的时候需要顺便把这些**数据占用的字节数**也存起来

     1. 真正的数据内容
     2. 占用的字节数

     在Compact 行格式中，把所有变长字段的真实数据==占用的字节长度==都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照**列的顺序**==逆序==存放，再次强调一遍，是逆序存放！

     **变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度
     是不储存的**

  2. NULL值列表

  3. 记录头信息

     固定的5 个字节组成。5 个字节也就是40 个二进制位，不同的位代表不同的意思，如图：

     ![image-20221017210110575](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017210110575.png)

* **记录的真实数据**

  MySQL 会为每个记录默认的添加一些列（也称为隐藏列）

  ![image-20221017210225027](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017210225027.png)

  InnoDB 表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique 键作为主键，如果表中连Unique 键都没有定义的话，则InnoDB 会为表默认添加一个名为row_id 的隐藏列作为主键。**所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 transaction_id和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。**

# 页

多个行格式组成的一个整体可以看成是`User Records`。它是==页==这个结构下的一部分，==页==大致划分为7个部分。有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。

![image-20221017211225347](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017211225347.png)

我们自己存储的记录会按照我们指定的**行格式**存储到`User Records` 部分。但是在一开始生成页的时候，其实并没有`User Records` 这个部分，每当我们插入一条记录，都会从`Free Space` 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到`User Records` 部分，当`Free Space` 部分的空间全部被`User Records` 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：

![image-20221017211338228](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017211338228.png)

**为了更好的管理在User Records 中的这些记录**， InnoDB 根据行格式中的`记录头信息`做了一些操作，往下看。

先创建一个表：

```bash
mysql> CREATE TABLE page_demo(
-> c1 INT,
-> c2 INT,
-> c3 VARCHAR(10000),
-> PRIMARY KEY (c1)
-> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.03 sec)
```

**c1 列指定为主键，所以在具体的行格式中InnoDB就没必要为我们去创建那个所谓的 row_id 隐藏列了。**这个表中记录的行格式示意图就是这样的：

![image-20221017211726666](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017211726666.png)

向`page_demo` 表中插入几条记录：

```bash
mysql> INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'),
(4, 400, 'dddd');
Query OK, 4 rows affected (0.00 sec)
Records: 4 Duplicates: 0 Warnings: 0
```

![image-20221017211839515](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017211839515.png)

* **delete_mask**

  这个属性标记着当前记录是否被删除，占用1个二进制位，值为0 的时候代表记录并没有被删除，为1 的时候代表记录被删除掉了。

  移除数据之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的**垃圾链表**，在这个链表中的记录占用的空间称之为所谓的**可重用空间**，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

* **min_rec_mask**

  B+树的每层**非叶子节点**中的**最小记录**都会添加该标记，我们自己插入的四条记录的min_rec_mask 值都是0 ，意味着它们都不是B+ 树的非叶子节点中的最小记录。

* **heap_no**

  这个属性表示当前记录在本页中的位置。对于一条完整的记录来说，比较记录的大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别是： 1 、2 、3 、4 ，这也就意味着这4条记录的大小从小到大依次递增。

  有两条规定好的**伪记录**：分别为**最小记录**与**最大记录**。这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的，如图所示：

  ![image-20221017212249227](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017212249227.png)

  它们并不存放在页的`User Records` 部分，他们被单独放在一个称为`Infimum + Supremum` 的部分，如图所示：

  ![image-20221017212409180](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017212409180.png)

  最小记录和最大记录的heap_no 值分别是0 和1 ，也就是说它们的位置最靠前。

* **record_type**

  一共有4种类型的记录， 0 表示普通记录， 1 表示B+树非叶节点记录（即目录）， 2 表示最小记录， 3 表示最大记录。

* **next_record**

  它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。

  ![image-20221017212641074](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017212641074.png)

  **不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个**
  **节点是按照主键值由小到大的顺序连接起来的。**

# Page Directory页目录

每条记录在页中按照主键值由小到大顺序串联成一个单链表，如何高效查找？**核心思想：二分法。**

我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。设计InnoDB 的大叔们为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：

1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）**划分为几个组**。
2. **每个组的最后一条记录**（也就是组内最大的那条记录）的头信息中的**n_owned** 属性表示该记录拥有多少条记录，也就是**该组内共有几条记录。**
3. 将每个组的最后一条记录的**地址偏移量**单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的**Page Directory** ，也就是**页目录**（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为**槽**（英文名： **Slot** ），所以这个页面目录就是由槽组成的。

**对于最小记录所在的分组只能有 1 条记录，**最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。

==所有的数据页形成一个双链表==

# 没有索引的查找

## 在一个页中的查找

* 以主键为搜索条件

  在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

* 以其他列作为搜索条件

  无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。

## 在很多页中查找

* 定位到记录所在的页
* 在一个页中的查找



## 索引

**定位到记录所在的页？**

### 一个简单的索引方案

如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？还记得我们为根据主键值快速定位一条记录在页中的位置而设立的**页目录**么（一条记录在页中的哪个位置——槽）？我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录（一条记录在哪个页——索引），建这个目录必须完成下边这些事儿：

* 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。**页分裂**。

  假设我们的每个数据页最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。有了这个假设之后我们向`index_demo` 表插入3条记录：

  ```mysql
  mysql> INSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y');
  Query OK, 3 rows affected (0.01 sec)
  Records: 3 Duplicates: 0 Warnings: 0
  ```

  那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：

  ![image-20221017215454126](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017215454126.png)

**由于数据页的编号可能并不是连续的**，所以在向index_demo 表中插入许多条记录后，可能是这样的效果：

![image-20221017215830375](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017215830375.png)

因为这些16KB 的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，**每个页对应一个目录项**，每个目录项包括下边两个部分：

* 页的用户记录中最小的主键值，我们用key 来表示。
* 页号，我们用page_no 表示。

![image-20221017220058514](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017220058514.png)



这里的目录项就是所谓的==索引==。

# InnoDB中的索引方案

上边之所以称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录项而==假设所有目录项都可以在物理存储器上连续存储==，但是这样做有几个问题：

* InnoDB 是使用页来作为管理存储空间的基本单位，也就是最多能保证16KB 的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。
* 我们时常会对记录进行增删，假设我们把页28 中的记录都删除了， 页28 也就没有存在的必要了，那意味着目录项2 也就没有存在的必要了，这就需要把目录项2 后的目录项都向前移动一下，这种牵一发而动全身的设计不是什么好主意～

解决方法：复用之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。那InnoDB 怎么区分一条记录是普通的用户记录还是目录项记录呢？别忘了记录头信息里的`record_type` 属性，它的各个取值代表的意思如下：

* 0 ：普通的用户记录
* 1 ：目录项记录
* 2 ：最小记录
* 3 ：最大记录

![image-20221017220541008](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017220541008.png)

新的问题：在这个查询步骤的第1步中我们需要**定位存储目录项记录的页**，但是这些页在存储空间中也可能不挨着，如果我们表中的数据非常多则会产生很多存储目录项记录的页，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？其实也简单，为这些存储目录项记录的页**再生成一个更高级的目录**，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：

![image-20221017221510871](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017221510871.png)

随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：

![image-20221017221543511](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017221543511.png)

不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到B+ 树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出来，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为叶子节点或叶节点，其余用来存放目录项的节点称为非叶子节点或者内节点，其中B+ 树最上边的那个节点也称为根节点。

一般情况下，我们用到的B+ 树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的Page irectory （页目录），所以在页面内也可以通过二分法实现快速定位记录，这不是很牛么，哈哈！

## 聚簇索引

B+ 树本身就是一个目录，或者说本身就是一个索引。它有两个特点：

* 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
  * 页内的记录是按照主键的大小顺序排成一个单向链表。
  * 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
  * 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。
* B+ 树的叶子节点存储的是完整的用户记录。

我们把具有这两种特性的B+ 树称为**聚簇索引**。InnoDB 存储引擎会自动的为我们创建聚簇索引。在InnoDB 存储引擎中， 聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的==索引即数据，数据即索引==。

## 二级索引

上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用。

以别的列作为搜索条件时，可以多建几棵B+ 树，不同的B+ 树中的数据采用不同的排序规则。比方说我们用c2 列的大小作为数据页、页中记录的排序规则，再建一棵B+ 树，效果如下图所示：

![image-20221017222031708](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20221017222031708.png)

这个B+ 树与上边介绍的聚簇索引有几处不同：

* 使用记录c2 列的大小进行记录和页的排序，这包括三个方面的含义：
  * 页内的记录是按照c2 列的大小顺序排成一个单向链表。
  * 各个存放用户记录的页也是根据页中记录的c2 列大小顺序排成一个双向链表。
  * 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2 列大小顺序排成一个双向链表。
* B+ 树的叶子节点存储的并不是完整的用户记录，而只是==c2列+主键==这两个列的值。
* 目录项记录中不再是**主键+页号**的搭配，而变成了**c2列+页号**的搭配。

由于这个B+ 树的叶子节点中的记录只存储了c2 和c1 （也就是主键）两个列，查找数据时，需要再根据主键值去聚簇索引中再查找一遍完整的用户记录。这个过程也被称为==回表==。

## 联合索引

本质上就是二级索引，并且索引越多，新增越多棵B+树。



# MyISAM中的索引方案简单介绍

