# 内存中的覆盖与交换

在上一篇3.1.2内存管理的概念中，我们提到了内存的虚拟技术，也就是操作系统对==内存空间的扩充==。现在来介绍一下，对内存空间扩充的两种技术，覆盖技术和交换技术。

## 覆盖技术

早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常出现内存大小不够的情况。

后来人们引入==覆盖技术==，用来==解决“程序大小超过物理内存总和”的问题==。

覆盖技术的思想：将==程序分为多个段（多个模块）==。常用的段常驻内存，不常用的段根据需要调入或调出内存。

内存中分为==一个“固定区”==和==若干个“覆盖区”==。

常驻内存的段放在==固定区==，调入后就不再调出内存（除非运行结束）；不常用的段放在==覆盖区==，需要时调入，不需要时调出。

![image-20220922171359680](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20220922171359680.png)

以上图举例，左侧是某程序x的调用结构。A模块是该程序的主要模块，理应放入==固定区==，固定去的大小就是A模块运行所需大小；B模块和C模块只会执行其中一个模块（可以想象为if-else），理应放入覆盖区0（可以有多个覆盖区），覆盖区大小是B和C中所需容量的最大值，D、E、F同理，放入覆盖区1，覆盖区大小规则同上，取最大值。

如果不采用覆盖技术，上述例子需要内存空间就是各个模块所需空间的总和52k。而采用覆盖技术，内存所需空间只要30k。覆盖技术就是按照程序自身逻辑结构，让哪些不可能同时被访问的程序段共享同一个覆盖区。

==缺点==

由于覆盖技术强烈依赖照程序自身逻辑结构，必须由程序员声明覆盖结构，操作系统完成自动覆盖。这样做，==对用户不透明==，增加了用户编程负担。==覆盖技术只用于早期的操作系统中，现在已成为历史==。

下面介绍==交换技术==

## 交换技术

当内存空间紧张时，系统将内存中某些进程暂时==换出==外存，把外存中某些已具备运行条件的进程==换入==内存（进程在内存与外存之间动态调度）。

暂时换出外存等待的进程，状态为==挂起状态==（suspend）。

挂起态又进一步细分为==就绪挂起==、==阻塞挂起==。

（进程状态的知识点可以复习进程部分的文章）

==下面思考几个问题==

1. 应该在外存的什么位置保存被换出的进程？
2. 什么时候应该交换？
3. 应该交换哪些进程？

==回答第一个问题==，应该在外存的什么位置保存被换出的进程？

现代具有对换功能的操作系统中，通常把磁盘空间分为==文件区==和==对换区==。==文件区==用于存放文件，==追求存储空间的利用率==，因此对文件区空间的管理采用==离散分配方式==；==对换区==空间只占磁盘空间的小部分，==被换出的进程数据就存放在对换区==。由于对换的速度直接影响到系统的整体速度，对换区的空间管理==追求换入换出速度==，因此对换区通常采用==连续分配方式==（学过文件管理章节即可理解）。

总之，==对换区的输入输出速度比文件区的更快==，虽然都是磁盘的某个空间，但是因为管理（计算）的方式不一样，它们的速度也不一样。

==回答第二个问题==，什么时候应该交换？

交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生==缺页==，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就暂停换出。（这里涉及的缺页和缺页率的概念，可以搜索操作系统专栏后续的相关文章）

==回答第三个问题==，应该交换哪些进程？

这里给出一些参考的思路

1. 可优先换出阻塞进程
2. 可换出优先级低的进程
3. 为了防止优先级低的进程在被调入内存后很快又被换出，导致时间被浪费，有的系统还会考虑进程在内存的驻留时间(==注意==：PCB进程控制块会常驻内存，不会被换出内存)
4. ...