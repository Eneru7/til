# 1.内存的基础知识

## 什么是内存？有何作用？

内存是用于存放数据的硬件。程序执行前==需要先放到内存才能被CPU处理==。

## 思考

问题：在多道程序环境下，系统中会有多个程序并发执行，也就是说多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据放在什么地方呢？

方案：给内存的储存单元编码地址。内存地址从0开始，每个地址对应一个存储单元。并且计算机有不同的**编址方式**：

**按字节编址**，则每个储存单元大小为**1字节**，即1B，即8个二进制位。

**按字编址**，假设计算机字长16位，则每个存储单元大小位**1字**，每个字大小即计算机字长位数。

## 内存在进程运行中的作用

首先，进程的运行原理——==指令==

![image-20220922095431538](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20220922095431538.png)

如上图，用**高级语言**编写的代码，经过**编译**，生成与之对应的**机器指令**，这些机器指令是用二进制编写的，可以被CPU识别。指令和数据在内存中的情况如下如所示：

![image-20220922101737142](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20220922101737142.png)

进程概念补充：

每个进程在逻辑上由三个部分组成

1. 程序段
2. 数据段
3. PCB（进程控制块）

CPU根据进程中程序段里的指令来执行相应操作，依次执行这些指令。比如此时执行**指令1（00101100,00000011,01001111)，数据传送指令**。把括号中的三个内容看作三个参数，第一个参数叫做==操作码==。CPU首先根据操作码判断要做一件什么事情，指令1中的操作码就是让CPU进行数据的传送。后面两个参数都是地址，综合看指令1就是让CPU把==第三个参数==对应的地址中的数据，==传送==到第二个参数对应的==寄存器==中。如下图所示：

![image-20220922102524520](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20220922102524520.png)

接着执行**指令2（10010010,00000011,00000001)， 加法指令**。==参数1==，依然是==操作码==，这里指加法操作；==参数2==，指要操作的地址；==参数3==，指要相加的数量。综合看指令2就是让CPU把参数2对应的地址中的数据加上参数3对应的值。如下图所示：

![image-20220922105839292](https://raw.githubusercontent.com/Eneru7/img/main/img_folder/image-20220922105839292.png)

接着执行**指令3（00101100,01001111,00000011)，数据传送指令**。同指令1，只是参数2和参数3内容对调了，意味着把寄存器中的数据传回变量x所在地址。这里就不展开了。

==需要强调的是：==这里给出的指令内容并不严谨，是为了可以比较直观地体会指令与CPU的合作过程。

可见，我们写的代码要翻译成CPU能识别的指令。这些指令回告诉CPU去内存中哪些地址==读取或者写入==数据。在上面的例子中，指令中直接给出了变量x的**实际存放地址**（==物理地址==），但实际在生成机指令的时候并不知道进程的数据回被放在什么位置。所以==编译==生成的指令一般是使用**逻辑地址**（==相对地址==）。

## 逻辑（相对）地址VS物理（绝对）地址

> 逻辑是相对的，因为逻辑上“参照物”可以多变，
>
> 物理是绝对的，“参照物”变了，本身并没有发生什么改变。

==举例==

宿舍中，学生4人，尾号分别是[0,1,2,3]。

4人一起入住酒店，酒店给它们安排4间==房号相连==的房间[5,6,7,8]。4人以==尾号递增==的顺序依次入住。

这里，4人的尾号是一种==相对位置==，房间的编号是==绝对位置==。

==只要知道==0号学生住房编号==N==，就知道M号同学的住房编号==N+M==。

实际上，因为学号和房号有这种==相连递增==的规律，只要知道任一学生的学号和房号，都能推算出其他学生的住房编号。

==举例结束==，回到指令的概念中。指令中的地址也采用这种思想，编译时产生的指令只关心==相对地址==，实际放入内存中时再想办法根据起始位置得到==绝对地址==。换句话说，CPU所操作的变量一定是存在内存中的某个进程范围内的，而创建一个进程时一定会记录下这个进程的==起始位置（物理地址）==。编译时只需要确定变量x存放的相对地址100，在需要操作变量x时，用起始位置+相对地址就可以定位到x。