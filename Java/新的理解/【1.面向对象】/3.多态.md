# Java中的多态

## 什么是多态?

多态的概念比较简单，就是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。

如果按照这个概念来定义的话，那么多态应该是一种==运行期==的状态。

## 多态的必要条件

为了实现运行期的多态，或者说是动态绑定，需要满足三个条件。

1. 有类继承或者接口实现
2. 子类要重写父类的方法
3. 父类的引用指向子类的对象

简单来一段代码解释下：

```java
public class Parent{
    public void call(){
        sout("I'm Parent");
    }
}
class Son extends Parent{//1.有类继承或者接口实现
    public void call(){//2.子类要重写父类的方法
        sout("I'm Son");
    }
}
class Daughter extend Parent{//1.有类继承或者接口实现
    public void call(){//2.子类要重写父类的方法
        sout("I'm Daughter");
    }
}
public class Test{
    public static void main(String[] args){
        Parent p1 = new Son();//3.父类的引用指向子类的对象
        p1.call();//"I'm Son"
        Parent p2 = new Daughter();//3.父类的引用指向子类的对象
        p2.call();//"I'm Daughter"
    }
}
```

这样，就实现了多态，同样是Parent 类的实例，p.call 调用的是Son 类的实现、p1.call 调用的是Daughter 的实现。

有人说，你自己定义的时候不就已经知道p 是son，p1 是Daughter 了么。但是，有些时候你用到的对象并不都是自己声明的啊。

比如Spring 中的IOC 出来的对象，你在使用的时候就不知道他是谁，或者说你可以不用关心他是谁。根据具体情况而定。

另外，还有一种说法，包括维基百科也说明，多态还分为==动态多态==和==静态多态==。

上面提到的那种动态绑定认为是动态多态，因为只有在==运行期==才能知道真正调用的是哪个类的方法。

还有一种静态多态，一般认为Java 中的函数重载是一种==静态多态==，因为他需要在==编译期==决定具体调用哪个方法。

关于这个动态静态的说法，我更偏向于重载和多态其实是无关的。

但是也要看情况，普通场合，我会认为只有方法的重写算是多态，毕竟这是我的观点。但是如果在面试的时候，我“可能”会认为重载也算是多态，毕竟面试官也有他的观点。我会和面试官说：我认为，多态应该是一种运行期特性，Java 中的重写是多态的体现。不过也有人提出重载是一种静态多态的想法，这个问题在StackOverflow 等网站上有很多人讨论，但是并没有什么定论。我更加倾向于重载不是多态。

这样沟通，既能体现出你了解的多，又能表现出你有自己的思维，不是那种别人说什么就是什么的。

## 动态绑定和静态绑定

弄清调用对象方法的执行过程十分重要.下面是调用过程的详细描述:

1.编译器查看对象的==声明类型==（注意和实际类型区分）和方法名。假设调用x.f(param)，且隐式参数x声明为C类的对象。需要注意的是：有可能存在多个名字为f，但是参数类型不一样的方法。例如，可能存在f(int)和f(Stirng)。编译器将会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法。

至此，编译器以获得所有可能被调用的候选方法。

2.接下来，编译器将查看调用方法时提供的==参数类型==。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配的方法，就选择这个方法。这个过程被称为==重载解析(overloading resolution)==。例如，对于调用x.f("Hello")来说，编译器将会挑选f(String)，而不是f(int)。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与值匹配，就会报告一个错误。

至此，编译器以获得需要调用的方法名字和参数类型。

3.如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确知道应该调用哪个方法，我们将这种调用方式成为==静态绑定（static binding）==。于此对应的是，调用的方法依赖于隐式参数的==实际类型==，并且在==运行时实现动态绑定==。在上面的举例中，采用动态绑定的方式生成一条调用f(Stirng)的指令。

4.当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它，否则，将在D类的超类中寻找f(String)，以此类推。

每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个==方法表(method table)==，其中列出了所有方法的签名（方法的签名指方法的名字和参数列表）和实际调用的方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。在前面的例子中，虚拟机搜索D类的方法表，以便寻找与调用f(String)向匹配的方法。这个方法既可能是D.f(Sring)，也有可能是X.f(String)，这里的X是D的超类。如果调用super.f(param)，编译器将对隐式参数超类的方法表进行搜索。